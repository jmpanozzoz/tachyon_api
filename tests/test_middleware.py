import pytest
from httpx import AsyncClient, ASGITransport
from tachyon_api import Tachyon


# Middleware defined as a class (traditional approach)
class SimpleHeaderMiddleware:
    """
    A middleware that adds a custom header to the response.
    Implements the ASGI specification for class-based middlewares.
    """

    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        # We only process HTTP requests
        if scope["type"] != "http":
            return await self.app(scope, receive, send)

        # We create a wrapper for 'send' that allows us to modify the response
        async def send_wrapper(message):
            if message["type"] == "http.response.start":
                # Clone the headers to avoid modifying the original message
                headers = list(message.get("headers", []))
                # Add our custom header
                headers.append((b"X-Class-Middleware", b"class middleware was here"))
                # Replace the headers in the message
                message["headers"] = headers
            # Send the modified message
            await send(message)

        # Continue with the middleware chain
        await self.app(scope, receive, send_wrapper)


@pytest.mark.asyncio
async def test_class_middleware():
    """
    Test to verify that a class-based middleware can intercept and modify
    the response generated by an endpoint when added with add_middleware.
    """
    # Create a base Tachyon application
    app = Tachyon()

    # Define a simple endpoint for testing
    @app.get("/test_class_middleware")
    def test_endpoint():
        return {"ok": True}

    # Wrap the application with our middleware manually
    # This simulates what add_middleware should do internally
    wrapped_app = SimpleHeaderMiddleware(app)

    # Use the wrapped application in the ASGI transport
    transport = ASGITransport(app=wrapped_app)
    async with AsyncClient(transport=transport, base_url="http://testserver") as client:
        response = await client.get("/test_class_middleware")

    # Verify that the response is correct
    assert response.status_code == 200
    assert response.json() == {"ok": True}
    # Verify that the middleware has added the header
    assert response.headers["X-Class-Middleware"] == "class middleware was here"


@pytest.mark.asyncio
async def test_decorator_middleware():
    """
    Test to verify that a middleware defined with the @app.middleware decorator
    can intercept and modify the response generated by an endpoint.
    """
    # Create a base Tachyon application
    app = Tachyon()

    # Define a middleware using the decorator
    @app.middleware()
    async def decorator_middleware(scope, receive, send, app):
        """Middleware defined with the decorator that adds a custom header"""
        if scope["type"] != "http":
            return await app(scope, receive, send)

        async def send_wrapper(message):
            if message["type"] == "http.response.start":
                headers = list(message.get("headers", []))
                headers.append(
                    (b"X-Decorator-Middleware", b"decorator middleware was here")
                )
                message["headers"] = headers
            await send(message)

        await app(scope, receive, send_wrapper)

    # Define a simple endpoint for testing
    @app.get("/test_decorator_middleware")
    def test_endpoint():
        return {"ok": True}

    # Use the application in the ASGI transport
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://testserver") as client:
        response = await client.get("/test_decorator_middleware")

    # Verify that the response is correct
    assert response.status_code == 200
    assert response.json() == {"ok": True}
    # Verify that the middleware has added the header
    assert response.headers["X-Decorator-Middleware"] == "decorator middleware was here"


@pytest.mark.asyncio
async def test_multiple_middlewares():
    """
    Test to verify that multiple middlewares can be applied
    using both approaches (class and decorator).
    """
    # Create a base Tachyon application
    app = Tachyon()

    # Middleware 1: Using the decorator
    @app.middleware()
    async def first_middleware(scope, receive, send, app):
        """First middleware that adds a header"""
        if scope["type"] != "http":
            return await app(scope, receive, send)

        async def send_wrapper(message):
            if message["type"] == "http.response.start":
                headers = list(message.get("headers", []))
                headers.append((b"X-First-Middleware", b"first middleware was here"))
                message["headers"] = headers
            await send(message)

        await app(scope, receive, send_wrapper)

    # Middleware 2: Using class and add_middleware method
    class SecondMiddleware:
        def __init__(self, app):
            self.app = app

        async def __call__(self, scope, receive, send):
            if scope["type"] != "http":
                return await self.app(scope, receive, send)

            async def send_wrapper(message):
                if message["type"] == "http.response.start":
                    headers = list(message.get("headers", []))
                    headers.append(
                        (b"X-Second-Middleware", b"second middleware was here")
                    )
                    message["headers"] = headers
                await send(message)

            await self.app(scope, receive, send_wrapper)

    # Apply the second middleware manually
    wrapped_app = SecondMiddleware(app)

    # Test endpoint
    @app.get("/test_multiple_middlewares")
    def test_endpoint():
        return {"ok": True}

    # Use the wrapped application in the ASGI transport
    transport = ASGITransport(app=wrapped_app)
    async with AsyncClient(transport=transport, base_url="http://testserver") as client:
        response = await client.get("/test_multiple_middlewares")

    # Verify that the response is correct
    assert response.status_code == 200
    assert response.json() == {"ok": True}

    # Verify that both middlewares have added their headers
    assert response.headers["X-First-Middleware"] == "first middleware was here"
    assert response.headers["X-Second-Middleware"] == "second middleware was here"
